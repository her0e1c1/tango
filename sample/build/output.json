[{"frontText": "What is bisect_left?", "backText": "import pytest\nfrom bisect import bisect_left\n\n\"\"\"\n`bisect_left(sl, a)` returns the smallest index in the sorted list `sl`\nwhere an element greater than or equal to `a` exists\n\"\"\"\n\n\ndef my_bisect_left(sl, a):\n    lo, hi = 0, len(sl)\n    while lo < hi:\n        mi = (lo + hi) // 2\n        if sl[mi] >= a:\n            hi = mi\n        else:\n            lo = mi + 1\n    return hi\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[(sl := [1, 1, 1, 3, 4, 4, 4, 5, 6, 6]), 0], 0],\n        [[sl, 1], 0],\n        [[sl, 2], 3],\n        [[sl, 3], 3],\n        [[sl, 4], 4],\n        [[sl, 5], 7],\n        [[sl, 6], 8],\n        [[sl, 7], 10],  # = len(sl) if out of index\n        [[sl, 12345], 10],\n    ],\n)\ndef test(args, expected):\n    assert bisect_left(*args) == expected\n    assert my_bisect_left(*args) == expected", "uniqueKey": "test/graycode/test_graycode.py", "tags": ["py", "graycode"]}, {"frontText": "What is bisect_left?", "backText": "import pytest\nfrom bisect import bisect_left\n\n\"\"\"\n`bisect_left(sl, a)` returns the smallest index in the sorted list `sl`\nwhere an element greater than or equal to `a` exists\n\"\"\"\n\n\ndef my_bisect_left(sl, a):\n    lo, hi = 0, len(sl)\n    while lo < hi:\n        mi = (lo + hi) // 2\n        if sl[mi] >= a:\n            hi = mi\n        else:\n            lo = mi + 1\n    return hi\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[(sl := [1, 1, 1, 3, 4, 4, 4, 5, 6, 6]), 0], 0],\n        [[sl, 1], 0],\n        [[sl, 2], 3],\n        [[sl, 3], 3],\n        [[sl, 4], 4],\n        [[sl, 5], 7],\n        [[sl, 6], 8],\n        [[sl, 7], 10],  # = len(sl) if out of index\n        [[sl, 12345], 10],\n    ],\n)\ndef test(args, expected):\n    assert bisect_left(*args) == expected\n    assert my_bisect_left(*args) == expected", "uniqueKey": "test/binarysearch/test_bisect_left.py", "tags": ["py", "binarysearch"]}, {"frontText": "What is bisect_right?", "backText": "import pytest\nfrom bisect import bisect_right\n\n\"\"\"\n`bisect_right(sl, a)` returns the smallest index in the sorted list `sl`\nwhere an element greater than `a` exists\n\"\"\"\n\n\ndef my_bisect_right(sl, a):\n    lo, hi = 0, len(sl)\n    while lo < hi:\n        mi = (lo + hi) // 2\n        if sl[mi] > a:  # bisect_left uses >= operator here\n            hi = mi\n        else:\n            lo = mi + 1\n    return hi\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[(sl := [1, 1, 1, 3, 4, 4, 4, 5, 6, 6]), 0], 0],\n        [[sl, 1], 3],\n        [[sl, 2], 3],\n        [[sl, 3], 4],\n        [[sl, 4], 7],\n        [[sl, 5], 8],\n        [[sl, 6], 10],  # = len(sl) if out of index\n        [[sl, 7], 10],\n        [[sl, 12345], 10],\n    ],\n)\ndef test(args, expected):\n    assert bisect_right(*args) == expected\n    assert my_bisect_right(*args) == expected", "uniqueKey": "test/binarysearch/test_bisect_right.py", "tags": ["py", "binarysearch"]}, {"frontText": "Find x such that x^2 == n", "backText": "import pytest\n\n\ndef find_x(n):  # O(log(N))\n    lo, hi = 0, 2**32\n    while lo <= hi:\n        mi = (lo + hi) // 2\n        r = mi * mi\n        if r == n:\n            return mi\n        elif r < n:\n            lo = mi + 1\n        else:\n            hi = mi - 1\n    return None\n\n\ndef find_x_naive(n):  # O(N)\n    for x in range(n + 1):\n        if x * x == n:\n            return x\n    return None\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[0], 0],\n        [[1], 1],\n        [[8], None],\n        [[9], 3],\n        [[10], None],\n        [[(n := 123) * n - 1], None],\n        [[n * n], n],\n        [[n * n + 1], None],\n    ],\n)\ndef test(args, expected):\n    assert find_x(*args) == expected\n    assert find_x_naive(*args) == expected", "uniqueKey": "test/binarysearch/test_find_x.py", "tags": ["py", "binarysearch"]}, {"frontText": "Find the largest x such that x^2 <= n", "backText": "import pytest\n\n\ndef find_max_x(n):  # O(log(N))\n    lo, hi = 0, 2**32\n    while lo < hi:\n        mi = (lo + hi + 1) // 2  # Need +1 for finding max\n        if mi * mi <= n:\n            lo = mi\n        else:\n            hi = mi - 1\n    return lo\n\n\ndef find_max_x_naive(n):  # O(sqrt(N))\n    x = 0\n    while x * x <= n:\n        x += 1\n    return x - 1\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[0], 0],\n        [[1], 1],\n        [[8], 2],\n        [[9], 3],\n        [[10], 3],\n        [[(n := 12345) * n - 1], n - 1],\n        [[n * n], n],\n        [[n * n + 1], n],\n    ],\n)\ndef test(args, expected):\n    assert find_max_x(*args) == expected\n    assert find_max_x_naive(*args) == expected", "uniqueKey": "test/binarysearch/test_find_max_x.py", "tags": ["py", "binarysearch"]}, {"frontText": "Find the smallest x such that x^2 >= n", "backText": "import pytest\n\n\ndef find_min_x(n):  # O(log(N))\n    lo, hi = 0, 2**32\n    while lo < hi:\n        mi = (lo + hi) // 2\n        if mi * mi >= n:\n            hi = mi\n        else:\n            lo = mi + 1\n    return hi\n\n\ndef find_min_x_naive(n):  # O(sqrt(N))\n    x = 0\n    while x * x < n:\n        x += 1\n    return x\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[0], 0],\n        [[1], 1],\n        [[8], 3],\n        [[9], 3],\n        [[10], 4],\n        [[(n := 12345) * n - 1], n],\n        [[n * n], n],\n        [[n * n + 1], n + 1],\n    ],\n)\ndef test(args, expected):\n    assert find_min_x(*args) == expected\n    assert find_min_x_naive(*args) == expected", "uniqueKey": "test/binarysearch/test_find_min_x.py", "tags": ["py", "binarysearch"]}, {"frontText": "Given an array of numbers, return the length of the longest increasing subsequence (LIS)\nin which the elements are in strictly increasing order.", "backText": "import pytest\nfrom bisect import bisect_left\n\n\ndef lis(nums):\n    dp = []\n    for n in nums:\n        i = bisect_left(dp, n)\n        if i == len(dp):\n            dp.append(n)\n        else:\n            dp[i] = n\n    return len(dp)\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n      [[1], 1],\n      [[3, 2, 5, 1, 3, 1, 7, 4], 3],  # [3, 5, 7]\n      [[4, 2, 3, 1, 5], 3],  # [2, 3, 6]\n    ],\n)\ndef test(args, expected):\n    assert lis(args) == expected", "uniqueKey": "test/binarysearch/test_lis.py", "tags": ["py", "binarysearch"]}, {"frontText": "Returns True if a specified element exists in a sorted list of integers.", "backText": "import pytest\nfrom bisect import bisect_left\n\n\ndef has_element(sl, a):  # O(log(N))\n    i = bisect_left(sl, a)\n    return i < len(sl) and sl[i] == a\n\n\ndef has_element_naive(sl, a):  # O(N)\n    for s in sl:\n        if s == a:\n            return True\n    return False\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[(sl := [10, 30, 50]), 0], False],\n        [[sl, 10], True],\n        [[sl, 20], False],\n        [[sl, 30], True],\n        [[sl, 40], False],\n        [[sl, 50], True],\n        [[sl, 60], False],\n    ],\n)\ndef test(args, expected):\n    assert has_element(*args) == expected\n    assert has_element_naive(*args) == expected", "uniqueKey": "test/binarysearch/test_has_element.py", "tags": ["py", "binarysearch"]}, {"frontText": "Returns the number of a specified element in a sorted list of integers.", "backText": "import pytest\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right\n\n\ndef count_elements(sl, a):  # O(log(N))\n    return bisect_right(sl, a) - bisect_left(sl, a)\n\n\ndef count_elements_naive(sl, a):  # O(N)\n    c = defaultdict(int)\n    for s in sl:\n        c[s] += 1\n    return c[a]\n\n\n@pytest.mark.parametrize(\n    \"args,expected\",\n    [\n        [[(sl := [1, 1, 1, 3, 4, 4, 4, 5, 6, 6]), 0], 0],\n        [[sl, 1], 3],\n        [[sl, 2], 0],\n        [[sl, 3], 1],\n        [[sl, 4], 3],\n        [[sl, 5], 1],\n        [[sl, 6], 2],\n        [[sl, 7], 0],\n    ],\n)\ndef test(args, expected):\n    assert count_elements(*args) == expected\n    assert count_elements_naive(*args) == expected", "uniqueKey": "test/binarysearch/test_count_elements.py", "tags": ["py", "binarysearch"]}]